#[cfg(test)]
mod test;

use crate::{
    Error,
    advisory::model::AdvisoryHead,
    common::model::Score,
    vulnerability::model::{
        AnalysisAdvisory, AnalysisDetails, AnalysisResponse, AnalysisResult, VulnerabilityDetails,
        VulnerabilityHead, VulnerabilitySummary,
    },
};
use sea_orm::{EntityTrait, FromQueryResult, Statement, prelude::*};
use sea_query::{Expr, PgFunc};
use std::{
    collections::{BTreeMap, HashMap, btree_map::Entry},
    str::FromStr,
};
use tracing::instrument;
use trustify_common::{
    db::{
        limiter::LimiterTrait,
        query::{Columns, Filtering, Query},
    },
    memo::Memo,
    model::{Paginated, PaginatedResults},
    purl::Purl,
};
use trustify_entity::{advisory, cvss3, vulnerability, vulnerability_description};
use trustify_module_ingestor::common::Deprecation;

#[derive(Default)]
pub struct VulnerabilityService {}

impl VulnerabilityService {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn fetch_vulnerabilities<C: ConnectionTrait + Sync + Send>(
        &self,
        search: Query,
        paginated: Paginated,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let limiter = vulnerability::Entity::find()
            .filtering_with(search, Columns::from_entity::<vulnerability::Entity>())?
            .limiting(connection, paginated.offset, paginated.limit);

        let total = limiter.total().await?;
        let vulnerabilities = limiter.fetch().await?;

        Ok(PaginatedResults {
            total,
            items: VulnerabilitySummary::from_entities(&vulnerabilities, deprecation, connection)
                .await?,
        })
    }

    pub async fn fetch_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        identifier: &str,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        if let Some(vulnerability) = vulnerability::Entity::find_by_id(identifier)
            .one(connection)
            .await?
        {
            Ok(Some(
                VulnerabilityDetails::from_entity(&vulnerability, deprecation, connection).await?,
            ))
        } else {
            Ok(None)
        }
    }

    #[instrument(
        skip(self, connection),
        err(level=tracing::Level::INFO),
    )]
    pub async fn delete_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        id: &str,
        connection: &C,
    ) -> Result<u64, Error> {
        let query = vulnerability::Entity::delete_by_id(id);

        let result = query.exec(connection).await?;

        Ok(result.rows_affected)
    }

    #[instrument(
        skip_all,
        err(level=tracing::Level::INFO),
    )]
    pub async fn analyze_purls<C>(
        &self,
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &C,
    ) -> Result<AnalysisResponse, Error>
    where
        C: ConnectionTrait,
    {
        let mut warnings = HashMap::new();
        let query = Self::build_query(purls, connection, &mut warnings)?;

        let stmt = Statement::from_string(connection.get_database_backend(), query);
        log::debug!("Analyzing using: {stmt}");

        // Collect all query results
        let purls_with_vulnerabilities = connection.query_all(stmt).await.map_err(Error::from)?;

        // Extract advisory IDs from JSONB array
        #[derive(serde::Deserialize)]
        struct AdvisoryEntry {
            id: Uuid,
        }
        impl sea_orm::TryGetableFromJson for AdvisoryEntry {}

        // Extract all unique vulnerability_ids and advisory_ids in a single pass
        let mut vulnerability_ids: Vec<String> =
            Vec::with_capacity(purls_with_vulnerabilities.len());
        let mut advisory_ids_set: std::collections::HashSet<Uuid> =
            std::collections::HashSet::new();

        for purl_with_vulnerabilities in &purls_with_vulnerabilities {
            vulnerability_ids.push(purl_with_vulnerabilities.try_get("", "id")?);

            if let Some(advisories) = purl_with_vulnerabilities
                .try_get_by::<Option<Vec<AdvisoryEntry>>, _>("advisories")?
            {
                advisory_ids_set.extend(advisories.into_iter().map(|e| e.id));
            }
        }

        let advisory_ids: Vec<Uuid> = advisory_ids_set.into_iter().collect();

        // Pre-fetch vulnerability descriptions
        let vulnerability_descriptions = if !vulnerability_ids.is_empty() {
            vulnerability_description::Entity::find()
                .filter(
                    Expr::col(vulnerability_description::Column::VulnerabilityId)
                        .eq(PgFunc::any(vulnerability_ids.clone())),
                )
                .filter(vulnerability_description::Column::Lang.eq("en"))
                .all(connection)
                .await?
        } else {
            vec![]
        };

        let descriptions_map: HashMap<String, vulnerability_description::Model> =
            vulnerability_descriptions
                .into_iter()
                .map(|desc| (desc.vulnerability_id.clone(), desc))
                .collect();

        // Pre-fetch cvss3 scores
        let cvss3_scores = if !advisory_ids.is_empty() && !vulnerability_ids.is_empty() {
            cvss3::Entity::find()
                .filter(Expr::col(cvss3::Column::AdvisoryId).eq(PgFunc::any(advisory_ids.clone())))
                .filter(
                    Expr::col(cvss3::Column::VulnerabilityId).eq(PgFunc::any(vulnerability_ids)),
                )
                .all(connection)
                .await?
        } else {
            vec![]
        };

        let mut cvss3_map: HashMap<(Uuid, String), Vec<Score>> = HashMap::new();
        for score in cvss3_scores {
            if let Ok(converted_score) = Score::try_from(score.clone()) {
                cvss3_map
                    .entry((score.advisory_id, score.vulnerability_id))
                    .or_default()
                    .push(converted_score);
            }
        }

        // Pre-fetch advisories
        let advisories = if !advisory_ids.is_empty() {
            advisory::Entity::find()
                .filter(Expr::col(advisory::Column::Id).eq(PgFunc::any(advisory_ids)))
                .all(connection)
                .await?
        } else {
            vec![]
        };

        let advisories_map: HashMap<Uuid, advisory::Model> =
            advisories.into_iter().map(|adv| (adv.id, adv)).collect();

        // Process all rows
        let mut result = BTreeMap::new();

        for row in purls_with_vulnerabilities {
            let (requested_purl, head) = Self::row_to_vuln(
                row,
                connection,
                &descriptions_map,
                &cvss3_map,
                &advisories_map,
            )
            .await?;

            match result.entry(requested_purl.clone()) {
                Entry::Vacant(entry) => {
                    entry.insert(AnalysisResult {
                        details: vec![head],
                        warnings: warnings.remove(&requested_purl).unwrap_or_default(),
                    });
                }
                Entry::Occupied(mut entry) => {
                    entry.get_mut().details.push(head);
                }
            }
        }

        // add the remaining warnings
        for (purl, warnings) in warnings {
            result.entry(purl).or_default().warnings.extend(warnings);
        }

        Ok(AnalysisResponse(result))
    }

    /// Build the query for finding matching vulnerabilities
    fn build_query(
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &impl ConnectionTrait,
        warnings: &mut HashMap<String, Vec<String>>,
    ) -> Result<String, Error> {
        let query = purls
            .into_iter()
            .map(|p| {
                let p = p.as_ref();
                let purl = Purl::from_str(p)?;

                let Some(version) = purl.version else {
                    warnings
                        .entry(p.to_string())
                        .or_default()
                        .push("Unable to process: missing version component".to_string());
                    return Ok(None);
                };

                let ns_condition = match &purl.namespace {
                    Some(namespace) => {
                        let sql = "base_purl.namespace = $1";
                        Statement::from_sql_and_values(
                            connection.get_database_backend(),
                            sql,
                            [namespace.into()],
                        )
                        .to_string()
                    }
                    None => "base_purl.namespace IS NULL".to_string(),
                };

                let sql = format!(
                    r#"
SELECT
  $1 as requested_purl,
  vulnerability.id,
  vulnerability.title,
  vulnerability.reserved,
  vulnerability.published,
  vulnerability.modified,
  vulnerability.withdrawn,
  vulnerability.cwes,
  jsonb_agg(
    jsonb_build_object(
      'status', status.slug,
      'id', purl_status.advisory_id
    )
  ) AS advisories
FROM base_purl
  LEFT JOIN purl_status ON base_purl.id = purl_status.base_purl_id
  INNER JOIN version_range ON purl_status.version_range_id = version_range.id
  LEFT JOIN vulnerability ON purl_status.vulnerability_id = vulnerability.id
  INNER JOIN status ON purl_status.status_id = status.id
WHERE {ns_condition}
  AND base_purl.name = $2
  AND base_purl.type = $3
  AND version_matches($4, version_range.*) = TRUE
  AND status.slug NOT IN (
    'fixed',
    'not_affected',
    'recommended'
  )
GROUP BY
  vulnerability.id,
  vulnerability.title,
  vulnerability.reserved,
  vulnerability.published,
  vulnerability.modified,
  vulnerability.withdrawn,
  vulnerability.cwes,
  requested_purl
"#
                );
                let query = Statement::from_sql_and_values(
                    connection.get_database_backend(),
                    &sql,
                    [p.into(), purl.name.into(), purl.ty.into(), version.into()],
                );

                Ok(Some(query.to_string()))
            })
            .filter_map(Result::transpose)
            .collect::<Result<Vec<String>, Error>>()?
            .join(" UNION ALL ");

        Ok(query)
    }

    /// Take a row from [`Self::build_query`] and turn it into a result entry
    ///
    /// This will return a tuple of the original PURL and then the result
    #[instrument(
        skip_all,
        fields(purl, id),
        err(level=tracing::Level::INFO),
    )]
    async fn row_to_vuln<C>(
        row: QueryResult,
        connection: &C,
        descriptions_map: &HashMap<String, vulnerability_description::Model>,
        cvss3_map: &HashMap<(Uuid, String), Vec<Score>>,
        advisories_map: &HashMap<Uuid, advisory::Model>,
    ) -> Result<(String, AnalysisDetails), Error>
    where
        C: ConnectionTrait,
    {
        let requested_purl: String = row.try_get_by("requested_purl")?;

        let vulnerability = vulnerability::Model::from_query_result(&row, "")?;

        let span = tracing::Span::current();
        span.record("purl", &requested_purl);
        span.record("id", &vulnerability.id);

        // Look up description from pre-fetched map
        let description_memo = descriptions_map
            .get(&vulnerability.id)
            .map(|desc| Memo::Provided(Some(desc.clone())))
            .unwrap_or(Memo::Provided(None));

        let head = VulnerabilityHead::from_vulnerability_entity(
            &vulnerability,
            description_memo,
            connection,
        )
        .await?;

        /// result struct for getting the array of status/advisory entries
        #[derive(serde::Deserialize)]
        struct Entry {
            status: String,
            id: Uuid,
        }
        impl sea_orm::TryGetableFromJson for Entry {}

        // deserialize from JSONB

        let advisories: Option<Vec<Entry>> = row.try_get_by("advisories")?;

        // create a map for looking up the status once we resolved the ID to a struct
        // This also de-duplicates advisory IDs
        let statuses = advisories
            .into_iter()
            .flatten()
            .map(|e| (e.id, e.status))
            .collect::<HashMap<_, _>>();

        // Process advisories using pre-fetched data
        let mut status_map = BTreeMap::<String, Vec<AnalysisAdvisory>>::new();

        for (advisory_id, status) in &statuses {
            let Some(advisory) = advisories_map.get(advisory_id) else {
                continue;
            };

            // Look up scores from pre-fetched cvss3_map
            let scores: Vec<Score> = cvss3_map
                .get(&(*advisory_id, vulnerability.id.clone()))
                .cloned()
                .unwrap_or_default();

            let analysis_advisory = AnalysisAdvisory {
                advisory: AdvisoryHead::from_advisory(advisory, Memo::NotProvided, connection)
                    .await?,
                scores,
            };

            status_map
                .entry(status.clone())
                .or_default()
                .push(analysis_advisory);
        }

        Ok((
            requested_purl,
            AnalysisDetails {
                head,
                status: status_map,
            },
        ))
    }
}
