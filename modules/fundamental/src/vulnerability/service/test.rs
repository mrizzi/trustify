use crate::{
    purl::service::PurlService, sbom::service::SbomService,
    vulnerability::service::VulnerabilityService,
};
use std::str::FromStr;
use test_context::test_context;
use test_log::test;
use trustify_common::{
    db::query::{Query, q},
    model::Paginated,
    purl::Purl,
};
use trustify_cvss::cvss3::severity::Severity;
use trustify_test_context::TrustifyContext;

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn all_vulnerabilities(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "cve/CVE-2021-32714.json"])
        .await?;

    let vulns = service
        .fetch_vulnerabilities(
            Query::default(),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;

    assert_eq!(1, vulns.items.len());

    assert!(
        vulns.items[0]
            .head
            .description
            .as_ref()
            .unwrap()
            .starts_with("hyper is an HTTP library for Rust")
    );

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn statuses(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "cve/CVE-2021-32714.json"])
        .await?;

    let vuln = service
        .fetch_vulnerability("CVE-2021-32714", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    assert_eq!(2, vuln.advisories.len());

    log::debug!("{vuln:#?}");

    let rustsec_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "RUSTSEC-2021-0079");
    assert!(rustsec_advisory.is_some());
    let rustsec_advisory = rustsec_advisory.unwrap();

    let cve_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "CVE-2021-32714");
    assert!(cve_advisory.is_some());
    let cve_advisory = cve_advisory.unwrap();

    let rustsec_statuses: Vec<_> = rustsec_advisory.purls.keys().collect();

    assert_eq!(2, rustsec_statuses.len());
    assert!(rustsec_statuses.contains(&&"fixed".to_string()));
    assert!(rustsec_statuses.contains(&&"affected".to_string()));

    let cve_statuses: Vec<_> = cve_advisory.purls.keys().collect();
    assert_eq!(0, cve_statuses.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn statuses_too(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "cve/CVE-2024-29025.json",
        "csaf/rhsa-2024-2705.json",
        "spdx/quarkus-bom-3.2.11.Final-redhat-00001.json",
        "spdx/quarkus-bom-3.2.12.Final-redhat-00002.json",
    ])
    .await?;

    let vuln = service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(2, vuln.advisories.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn commons_compress(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let vuln_service = VulnerabilityService::new();
    let sbom_service = SbomService::new(ctx.db.clone());

    // Ingest a CVE declaring the vulnerability present in versions
    // [1.21,1.26.0) of commons-compress, along with 2 sboms, each of
    // which includes a vulnerable version of commons-compress
    let ingest_results = ctx
        .ingest_documents([
            "cve/CVE-2024-26308.json",
            "spdx/SATELLITE-6.15-RHEL-8.json", // 1.21
            "spdx/OCP-TOOLS-4.11-RHEL-8.json", // 1.24
            "spdx/quarkus-bom-3.2.11.Final-redhat-00001.json", // 1.26.0.redhat-00001
        ])
        .await?;

    let sat_id = ingest_results[1].id.clone();

    let sat_sbom = sbom_service
        .fetch_sbom_details(sat_id, vec![], &ctx.db)
        .await?;
    assert!(sat_sbom.is_some());

    let sat_sbom = sat_sbom.unwrap();
    assert_eq!(1, sat_sbom.advisories.len());

    let sat_status = &sat_sbom.advisories[0].status[0];

    // first, ensure our assumptions are correct and
    // the pURL is indeed part of the SBOM we think
    // it is.
    assert_eq!(sat_status.status, "affected");

    assert_eq!(1, sat_status.packages.len());

    assert_eq!(
        sat_status.packages[0].purl[0].head.purl.to_string(),
        "pkg:maven/org.apache.commons/commons-compress@1.21"
    );

    let quarkus_id = ingest_results[3].id.clone();

    let quarkus_sbom = sbom_service
        .fetch_sbom_details(quarkus_id, vec![], &ctx.db)
        .await?;

    assert!(quarkus_sbom.is_some());

    let quarkus_sbom = quarkus_sbom.unwrap();

    // Quarkus should /not/ be affected.
    assert!(quarkus_sbom.advisories.is_empty());

    let vuln = vuln_service
        .fetch_vulnerability("CVE-2024-26308", Default::default(), &ctx.db)
        .await?
        .unwrap();

    log::debug!("{vuln:#?}");

    // Collect and sort the SBOMs by their document_id for consistent iteration.
    let mut sboms: Vec<_> = vuln.advisories[0].sboms.iter().collect::<Vec<_>>();
    sboms.sort_by_key(|sbom| sbom.head.document_id.clone().expect("No document id"));

    // Define the expected PURL and version pairs.
    let expected = [
        (
            "https://access.redhat.com/security/data/sbom/spdx/OCP-TOOLS-4.11-RHEL-8",
            "pkg:maven/org.apache.commons/commons-compress",
            "1.24.0",
        ),
        (
            "https://access.redhat.com/security/data/sbom/spdx/SATELLITE-6.15-RHEL-8",
            "pkg:maven/org.apache.commons/commons-compress",
            "1.21",
        ),
    ];

    // Iterate through sorted SBOMs and validate each entry.
    for (sbom, (expected_id, expected_purl, expected_version)) in sboms.iter().zip(&expected) {
        assert_eq!(
            sbom.head.document_id.clone().expect("No document id"),
            *expected_id
        );

        // Get the affected PURL status for the SBOM.
        let purl = sbom.purl_statuses["affected"]
            .iter()
            .next()
            .expect("no purl status");
        assert_eq!(purl.head.purl.to_base().to_string(), *expected_purl);
        assert_eq!(purl.head.purl.version.as_deref(), Some(*expected_version));
    }

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn sbom_without_cpe_matching(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let sbom_service = SbomService::new(ctx.db.clone());

    let ingest_results = ctx
        .ingest_documents([
            // This CSAF file has CPEs
            "csaf/rhsa-2025_10698.json",
            // This Syft-generate SBOM has no CPE
            "cyclonedx/mtr-rhel8-operator_1.2.7.json",
        ])
        .await?;

    let mtr_id = ingest_results[1].id.clone();

    let mtr_sbom = sbom_service
        .fetch_sbom_details(mtr_id, vec![], &ctx.db)
        .await?;
    assert!(mtr_sbom.is_some());

    let mtr_sbom = mtr_sbom.unwrap();
    // The test checks the advisory (with CPE) correlates with the SBOM (with no CPE)
    assert_eq!(1, mtr_sbom.advisories.len());
    assert_eq!(3, mtr_sbom.advisories[0].status.len());

    let mtr_status = &mtr_sbom.advisories[0].status[0];

    assert_eq!(mtr_status.status, "affected");

    assert_eq!(2, mtr_status.packages.len());

    assert_eq!(
        mtr_status.packages[0].purl[0].head.purl.to_string(),
        "pkg:rpm/redhat/libxml2@2.9.7-18.el8_10.1?arch=x86_64&distro=rhel-8.10&upstream=libxml2-2.9.7-18.el8_10.1.src.rpm"
    );

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn sbom_with_multiple_cpes_not_breaking(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let sbom_service = SbomService::new(ctx.db.clone());

    let ingest_results = ctx
        .ingest_documents([
            // This SBOM has multiple CPEs and test checks this works with conditions from CONTEXT_CPE_FILTER_SQL
            "spdx/SATELLITE-6.15-RHEL-8.json", // 1.21
        ])
        .await?;

    let sat_id = ingest_results[0].id.clone();

    let sat_sbom = sbom_service
        .fetch_sbom_details(sat_id, vec![], &ctx.db)
        .await?;
    assert!(sat_sbom.is_some());

    let sat_sbom = sat_sbom.unwrap();
    assert_eq!(0, sat_sbom.advisories.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn product_statuses(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let vuln_service = VulnerabilityService::new();
    let sbom_service = SbomService::new(ctx.db.clone());
    let purl_service = PurlService::new();

    let ingest_results = ctx
        .ingest_documents([
            "csaf/cve-2023-0044.json",
            "quarkus/v2/quarkus-bom-2.13.8.Final-redhat-00004.json",
        ])
        .await?;

    let quarkus_id = ingest_results[1].id.clone();

    let quarkus_sbom = sbom_service
        .fetch_sbom_details(quarkus_id, vec![], &ctx.db)
        .await?;

    assert!(quarkus_sbom.is_some());

    let quarkus_sbom = quarkus_sbom.unwrap();

    log::debug!("{quarkus_sbom:#?}");

    assert!(!quarkus_sbom.advisories.is_empty());
    let quarkus_adv = &quarkus_sbom.advisories[0].status[0];

    assert_eq!(quarkus_adv.status, "affected");
    assert_eq!(quarkus_adv.vulnerability.identifier, "CVE-2023-0044");

    assert_eq!(quarkus_adv.packages.len(), 1);
    assert_eq!(quarkus_adv.packages[0].purl.len(), 1);
    assert_eq!(quarkus_adv.packages[0].purl[0].head.purl, Purl::from_str("pkg:maven/io.quarkus/quarkus-vertx-http@2.13.8.Final-redhat-00004?repository_url=https://maven.repository.redhat.com/ga/&type=jar").unwrap());

    let vuln = vuln_service
        .fetch_vulnerability("CVE-2023-0044", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(1, vuln.advisories.len());

    let cve_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "https://www.redhat.com/#CVE-2023-0044");
    assert!(cve_advisory.is_some());
    let cve_advisory = cve_advisory.unwrap();

    log::debug!("{cve_advisory:#?}");

    assert_eq!(
        "pkg:maven/io.quarkus/quarkus-vertx-http",
        cve_advisory.sboms[0].purl_statuses["affected"]
            .clone()
            .into_iter()
            .next()
            .expect("no purl status")
            .head
            .purl
            .to_base()
            .to_string()
    );

    // Ensure that vuln->sbom mapping is good.
    let mut sboms: Vec<_> = vuln.advisories[0]
        .sboms
        .iter()
        .flat_map(|i| i.head.document_id.clone())
        .collect();
    sboms.sort();

    assert_eq!(
        sboms,
        ["https://access.redhat.com/security/data/sbom/spdx/quarkus-bom-2.13.8.Final-redhat-00004",],
    );

    // Ensure that purl->vuln mapping is good
    let purl = purl_service
        .purl_by_purl(
            &Purl::try_from("pkg:maven/io.quarkus/quarkus-vertx-http@2.13.8.Final-redhat-00004?repository_url=https://maven.repository.redhat.com/ga/&type=jar")?,
            Default::default(),
            &ctx.db,
        )
        .await?;

    log::debug!("{purl:#?}");
    assert!(purl.is_some());
    let purl = purl.unwrap();
    assert_eq!(1, purl.advisories.len());

    let cve_advisory = purl
        .advisories
        .iter()
        .find(|e| e.head.identifier == "https://www.redhat.com/#CVE-2023-0044");
    assert!(cve_advisory.is_some());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn delete_vulnerability(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["cve/CVE-2024-29025.json"]).await?;

    let vuln = service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?
        .expect("Vulnerability not found");

    assert_eq!(1, vuln.advisories.len());

    let id = &vuln.advisories[0].head.head.identifier;

    let affected = service.delete_vulnerability(id, &ctx.db).await?;
    assert_eq!(1, affected);

    assert!(
        service
            .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
            .await?
            .is_none()
    );

    let affected = service.delete_vulnerability(id, &ctx.db).await?;
    assert_eq!(0, affected);

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn vulnerability_queries(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "csaf/CVE-2023-20862.json",
        "cve/CVE-2023-20862.json",
        "cve/CVE-2023-42282.json",
        "csaf/RHBA-2024_1440.json",
        "cve/CVE-2023-39326.json",
        "csaf/rhsa-2023_5835.json",
        "cve/CVE-2023-39325.json",
        "cve/CVE-2023-44487.json",
        "cve/CVE-2024-7826.json",
        "cve/CVE-2017-20197.json",
    ])
    .await?;

    let vulns = service
        .fetch_vulnerabilities(q(""), Paginated::default(), Default::default(), &ctx.db)
        .await?;
    assert_eq!(7, vulns.items.len());
    let vulns = service
        .fetch_vulnerabilities(
            q("base_score>9"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-42282");
    let vulns = service
        .fetch_vulnerabilities(
            q("base_severity=critical"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-42282");
    let vulns = service
        .fetch_vulnerabilities(
            q("base_severity<high"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    tracing::debug!(test = "", "{vulns:#?}");
    assert_eq!(3, vulns.items.len());
    assert_eq!(
        *vulns.items[0].average_severity.as_ref().unwrap(),
        trustify_cvss::cvss3::severity::Severity::Medium
    );
    let vulns = service
        .fetch_vulnerabilities(
            q("base_severity>=high"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    tracing::debug!(test = "", "{vulns:#?}");
    assert_eq!(2, vulns.items.len());
    let vulns = service
        .fetch_vulnerabilities(
            q("20862"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-20862");

    let vulns = service
        .fetch_vulnerabilities(
            q("CVE-2024-7826"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].average_score, Some(6.2));
    assert_eq!(vulns.items[0].average_severity, Some(Severity::Medium));

    let vulns = service
        .fetch_vulnerabilities(
            q("CVE-2017-20197"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].average_score, Some(6.9));
    assert_eq!(vulns.items[0].average_severity, Some(Severity::Medium));

    let vulns = service
        .fetch_vulnerabilities(
            q("CVE-2023-39325"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(2, vulns.items[0].advisories.len());
    assert_eq!(vulns.items[0].advisories[0].score, Some(7.5));
    assert_eq!(vulns.items[0].advisories[0].severity, Some(Severity::High));
    assert_eq!(vulns.items[0].advisories[1].score, None);
    assert_eq!(vulns.items[0].advisories[1].severity, None);

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn analyze_purls(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "osv/RUSTSEC-2021-0079.json",
        "osv/GHSA-2ccf-ffrj-m4qw.json",
        "osv/GHSA-69ch-w2m2-3vjp.json",
        "osv/GHSA-ppp9-7jff-5vj2.json",
    ])
    .await?;

    // test empty request

    let result = service.analyze_purls(Vec::<&str>::new(), &ctx.db).await?;
    assert!(result.is_empty());

    // test some invalid PURLs

    for purl in ["this is not valid"].iter() {
        let result = service.analyze_purls(vec![purl], &ctx.db).await;
        assert!(result.is_err());
    }

    // test some unsuitable PURLs

    for purl in ["pkg:npm/missing.version"].iter() {
        let result = service.analyze_purls(vec![purl], &ctx.db).await;
        // must still be ok
        assert!(result.is_ok(), "{purl} should not fail the request");
        let result = result.unwrap();
        // has exactly one entry
        assert_eq!(result.len(), 1);
        // which is the purl
        let result = &result[*purl];
        // and has one warning, but no details
        assert_eq!(result.warnings.len(), 1);
        assert!(result.details.is_empty());
    }

    let expected = [
        "pkg:npm/%40fastify/passport@1.0.0",   // ECOSYSTEM:affected
        "pkg:cargo/hyper@0.14.9",              // SEMVER:affected - no namespace
        "pkg:golang/golang.org/x/text@v0.3.6", // GOLANG:affected
        "pkg:golang/golang.org/x/text@0.3.6",  // SEMVER:affected
    ];

    let not_found = [
        "pkg:npm/%40fastify/passport@2.3.0", // ECOSYSTEM:fixed
        "pkg:golang/github.com/metal3-io/baremetal-operator/apis@0.8.0", // Missing
        "pkg:cargo/hyper@0.14.11",           // SEMVER:fixed - no namespace
    ];

    let items: Vec<&str> = expected.iter().chain(&not_found).copied().collect();

    let result = service.analyze_purls(items, &ctx.db).await?;

    expected.iter().for_each(|&item| {
        assert!(
            result.contains_key(item),
            "Expected key '{item}' not found in result"
        )
    });
    not_found.iter().for_each(|&item| {
        assert!(
            !result.contains_key(item),
            "Unexpected key '{item}' found in result"
        )
    });
    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
#[ignore = "Requires #1873"]
async fn analyze_purls_no_score(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    const PURL: &str = "pkg:cargo/hyper@0.14.9";

    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2022-0022.json"]).await?;

    let result = service.analyze_purls([PURL], &ctx.db).await?;

    // ensure there is no warning

    assert!(result[PURL].warnings.is_empty());

    // ensure we get an entry

    assert_eq!(result.len(), 1);
    let advisory = &result[PURL].details[0];
    let status = &advisory.status["affected"][0];

    // the scores must be empty

    assert!(status.scores.is_empty());

    Ok(())
}
