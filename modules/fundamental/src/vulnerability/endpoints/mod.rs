#[cfg(test)]
mod test;

use crate::{
    db::DatabaseExt,
    endpoints::Deprecation,
    vulnerability::{
        model::{AnalysisRequest, AnalysisResponse, VulnerabilityDetails, VulnerabilitySummary},
        service::VulnerabilityService,
    },
};
use actix_web::{HttpResponse, Responder, get, post, web};
use time::OffsetDateTime;
use trustify_auth::{ReadAdvisory, authorizer::Require};
use trustify_common::{
    db::{Database, query::Query},
    model::{Paginated, PaginatedResults},
};
use trustify_entity::cvss3::Severity;
use trustify_query::TrustifyQuery;
use trustify_query_derive::Query;

pub fn configure(config: &mut utoipa_actix_web::service_config::ServiceConfig, db: Database) {
    let service = VulnerabilityService::new();
    config
        .app_data(web::Data::new(service))
        .app_data(web::Data::new(db))
        .service(all)
        .service(get)
        .service(analyze);
}

#[allow(dead_code)]
#[derive(Query)]
struct VulnerabilityQuery {
    id: String,
    title: Option<String>,
    reserved: Option<OffsetDateTime>,
    published: Option<OffsetDateTime>,
    modified: Option<OffsetDateTime>,
    withdrawn: Option<OffsetDateTime>,
    cwes: Option<Vec<String>>,
    base_score: Option<f64>,
    base_severity: Option<Severity>,
}

#[utoipa::path(
    tag = "vulnerability",
    operation_id = "listVulnerabilities",
    params(
        TrustifyQuery<VulnerabilityQuery>,
        Paginated,
    ),
    responses(
        (status = 200, description = "Matching vulnerabilities", body = PaginatedResults<VulnerabilitySummary>),
    ),
)]
#[get("/v2/vulnerability")]
/// List vulnerabilities
pub async fn all(
    state: web::Data<VulnerabilityService>,
    db: web::Data<Database>,
    web::Query(search): web::Query<Query>,
    web::Query(paginated): web::Query<Paginated>,
    web::Query(Deprecation { deprecated }): web::Query<Deprecation>,
    _: Require<ReadAdvisory>,
) -> actix_web::Result<impl Responder> {
    let tx = db.begin_read().await?;
    Ok(HttpResponse::Ok().json(
        state
            .fetch_vulnerabilities(search, paginated, deprecated, &tx)
            .await?,
    ))
}

#[utoipa::path(
    tag = "vulnerability",
    operation_id = "getVulnerability",
    params(
        ("id", Path, description = "ID of the vulnerability")
    ),
    responses(
        (status = 200, description = "Specified vulnerability", body = VulnerabilityDetails),
        (status = 404, description = "The vulnerability could not be found"),
    ),
)]
#[get("/v2/vulnerability/{id}")]
/// Retrieve vulnerability details
pub async fn get(
    state: web::Data<VulnerabilityService>,
    db: web::Data<Database>,
    id: web::Path<String>,
    web::Query(Deprecation { deprecated }): web::Query<Deprecation>,
    _: Require<ReadAdvisory>,
) -> actix_web::Result<impl Responder> {
    let tx = db.begin_read().await?;
    let vuln = state.fetch_vulnerability(&id, deprecated, &tx).await?;
    if let Some(vuln) = vuln {
        Ok(HttpResponse::Ok().json(vuln))
    } else {
        Ok(HttpResponse::NotFound().finish())
    }
}

#[utoipa::path(
  operation_id = "analyze",
  tag = "vulnerability",
  request_body = AnalysisRequest,
  responses(
      (status = 200, description = "Analyze the provided purls to search for known vulnerabilities", body = AnalysisResponse),
  ),
)]
#[post("/v2/vulnerability/analyze")]
/// Analyze the provided purls for the known vulnerabilities
pub async fn analyze(
    service: web::Data<VulnerabilityService>,
    db: web::Data<Database>,
    web::Json(AnalysisRequest { purls }): web::Json<AnalysisRequest>,
    _: Require<ReadAdvisory>,
) -> actix_web::Result<impl Responder> {
    let tx = db.begin_read().await?;
    let details = service.analyze_purls(purls, &tx).await?;

    Ok(HttpResponse::Ok().json(details))
}
